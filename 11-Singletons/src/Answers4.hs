-- | answers to section 4 questions in Singletons part 4 series
{-# LANGUAGE TypeInType           #-}
{-# LANGUAGE UndecidableInstances #-}

module Answers4 where

import Data.Kind
import Data.Singletons
import Data.Singletons.Prelude hiding (And, Foldr, FoldrSym0, FoldrSym1, FoldrSym2, FoldrSym3, Or,
                                sFoldr)
import Data.Singletons.Sigma
import Data.Singletons.TH hiding (Fold, Foldr, FoldrSym0, FoldrSym1, FoldrSym2, FoldrSym3, sFold,
                           sFoldr)


$(singletons [d|
  data DoorState = Opened | Closed | Locked
    deriving (Show, Eq, Ord)
  |])

data Door :: DoorState -> Type where
    UnsafeMkDoor :: { doorMaterial :: String } -> Door s

$(singletons [d|
  data Pass = Obstruct | Allow
    deriving (Show, Eq, Ord)
  |])

mkDoor :: Sing s -> String -> Door s
mkDoor _ = UnsafeMkDoor

{-
Write mergeDoor; What will the new state door state be ?


mergeDoor :: Door s -> Door t -> Door ????
mergeDoor d e = UnsafeMkDoor $ doorMaterial d ++ " and " ++ doorMaterial e
-}


$(singletons [d|
  mergeState :: DoorState -> DoorState -> DoorState
  mergeState = max
  |])

mergeDoor :: Door s -> Door t -> Door (MergeState s t)
mergeDoor d e = UnsafeMkDoor $ doorMaterial d ++ " and " ++ doorMaterial e

{-
 write type definition for Sigma and TyCon1

 da

-}

data Sigma_ (s :: Type) ::  (s ~> Type) -> Type where
  Pair :: forall s fst t. Sing (fst :: s) -> t @@ fst -> Sigma_ s t

{-
data family TyCon :: (k1 -> k2) -> k3
type TyCon1 = (TyCon  (k1 -> k2) -> (k1 ~> k2)) -- There is an instance for TyCon possibly generated by TH

data TyCon1 :: (k1 -> k2) -> (k1 ~> k2) -- generated data type


-}
{-
write:  mergeSomeDoor :: SomeDoor -> SomeDoor ->SomeDoor
-}

type SomeDoor = Sigma DoorState (TyCon1 Door)

mergeSomeDoor :: SomeDoor -> SomeDoor -> SomeDoor
mergeSomeDoor (s1 :&: d1) (s2 :&: d2) = sMergeState s1 s2 :&: mergeDoor d1 d2

{-
Let’s make a data type that represents a series of hallways, each linked by a door. A hallway is either an empty stretch with no door, or two hallways linked by a door. We’ll structure it like a linked list, and store the list of all door states as a type-level list as a type parameter:

write Hallway type

such that

ghci> let door1 = mkDoor SClosed "Oak"
ghci> let door2 = mkDoor SOpened "Spruce"
ghci> let door3 = mkDoor SLocked "Acacia"
ghci> :t door1 :<# door2 :<# door3 :<# HEnd

Hallway '[ 'Closed, 'Opened, 'Locked ]

-}

infixr 5 :<#

data Hallway (xs :: [DoorState]) :: Type where
  HEnd  :: Hallway '[]
  (:<#) :: Door s -> Hallway xs -> Hallway (s ': xs)

-- | write function to collapse all doors in a hallway
-- collapseHallway :: Hallway ss -> Door ?????

$(singletons [d|
  mergeStateList :: [DoorState] -> DoorState
  mergeStateList []     = Locked
  mergeStateList (x:xs) = x `mergeState` (mergeStateList xs)
  |])

collapseHallway :: Hallway ss -> Door (MergeStateList ss)
collapseHallway HEnd       = mkDoor SLocked "End of hallway"
collapseHallway (x :<# xs) = mergeDoor x (collapseHallway xs)

{-
 write type definition for  a ~> b
 data TyFun (a :: k) (b :: k)

 infixr 0 ~>

 type a ~> b = TyFun a b -> Type
-}

{-
 write global interpreter type family definition for defunctionalisation symbol a ~> a
-}

type family Apply_ (f :: a ~> b) (x :: a) ::  b

{-
 Given
 data Id :: a ~> a
 data Not :: Bool ~> Bool
 write an iterpreter instances.

 instance Apply Not ('True) = 'False
 instance Apply Not ('False) = 'True
-}

{-
$(singletons [d|
  and :: Bool -> (Bool -> Bool)
  and False _ = False
  and True  x = x
  ])

write the sing type family and defunctionalization symbols created by singleton function above

 type family And (x :: Bool) (y :: Bool) :: Bool where
   And 'False x = 'False
   And 'True x = x

 sAnd :: Sing (x :: Bool) -> Sing (y :: Bool) -> Sing (And x y)

 data AndSy0 :: Bool ~> (Bool ~> Bool)

 instance Apply AndSy0 x = AndSy1 x

 data AndSy1 ::  Bool -> Bool ~> Bool

 instance Apply (AndSy1 x) y = And x y

 data AndSy2 (Bool -> Bool) -> Bool

-}

{--
 what is the returned value of below kind functions

ghci> :kind! AndSym0 @@ 'False
AndS1 'False

ghci> :kind! AndSym1 'False @@ 'True
'False

ghci> :kind! AndSym1 'True  @@ 'True
'True

-}

{-
 we can lift any type constructor into a “free” defunctionalization symbol with TyCon1
 write definition for TyCon1 and its Apply (@@) instance
-}

data TyCon1_ :: (k1 -> k2) -> (k1 ~> k2)

{-
  write Maybe Int in terms of TyCon1
  TyCon1 ??? = Maybe Int

-}

type instance Apply_ (TyCon1_ Maybe) Int = Maybe Int
-- >>> :k! TyCon1 Maybe @@ Int

{-
 write Foldr type family in terms of defunctionalization symbols

 write a MergeSateList in terms of Foldr
-}

{-
 define a sing monoid isntance for DoorState in terms of mergeState
-}

{-
 Promote fold as a sing function
-}

{-
write a collapseSomeHallwat function that makes use of the promoted fold
-}

-- | define what a dependent pair is

-- | write definition for Sigma type

-- | define SomeDoor in terms of Sigma

-- | define SomeHallway as a dependentapair over [DoorState] with Hallway

-- exercises ??
